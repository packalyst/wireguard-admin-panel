package vpn

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"api/internal/database"
	"api/internal/helper"
)

// getNftablesPath returns the configured nftables ACL path
func getNftablesPath() string {
	return helper.GetNFTablesACLPath()
}

// GenerateAndApplyNftables generates nftables rules from the database and applies them
func GenerateAndApplyNftables() error {
	rules, err := generateNftablesRules()
	if err != nil {
		return err
	}

	nftablesPath := getNftablesPath()

	// Ensure directory exists
	os.MkdirAll(filepath.Dir(nftablesPath), 0755)

	// Write rules to file
	if err := os.WriteFile(nftablesPath, []byte(rules), 0644); err != nil {
		return fmt.Errorf("failed to write nftables rules: %v", err)
	}

	// Apply rules
	cmd := exec.Command("nft", "-f", nftablesPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to apply nftables rules: %v, output: %s", err, string(output))
	}

	log.Printf("Applied VPN ACL nftables rules")
	return nil
}

func generateNftablesRules() (string, error) {
	db, err := database.GetDB()
	if err != nil {
		return "", err
	}
	wgIPRange := helper.GetEnv("WG_IP_RANGE")
	hsIPRange := helper.GetEnv("HEADSCALE_IP_RANGE")

	// Get all clients
	rows, err := db.Query(`SELECT id, name, ip, type, acl_policy FROM vpn_clients`)
	if err != nil {
		return "", err
	}
	defer rows.Close()

	type client struct {
		ID     int
		Name   string
		IP     string
		Type   string
		Policy string
	}
	clients := make(map[int]client)

	for rows.Next() {
		var c client
		if err := rows.Scan(&c.ID, &c.Name, &c.IP, &c.Type, &c.Policy); err != nil {
			continue
		}
		clients[c.ID] = c
	}

	// Get all ACL rules (simplified: source can reach target)
	ruleRows, err := db.Query(`SELECT source_client_id, target_client_id FROM vpn_acl_rules`)
	if err != nil {
		return "", err
	}
	defer ruleRows.Close()

	type aclRule struct {
		SourceID int
		TargetID int
	}
	var rules []aclRule
	for ruleRows.Next() {
		var r aclRule
		if err := ruleRows.Scan(&r.SourceID, &r.TargetID); err != nil {
			continue
		}
		rules = append(rules, r)
	}

	// Build nftables rules
	var sb strings.Builder
	sb.WriteString("# VPN ACL nftables rules\n")
	sb.WriteString("# AUTO-GENERATED BY ADMIN PANEL - DO NOT EDIT\n")
	sb.WriteString("# Server: " + helper.GetEnv("SERVER_IP") + "\n\n")

	// Delete existing table if it exists
	sb.WriteString("table inet vpn_acl\ndelete table inet vpn_acl\n\n")

	sb.WriteString("table inet vpn_acl {\n")
	sb.WriteString("    chain forward {\n")
	sb.WriteString("        type filter hook forward priority 0; policy accept;\n\n")

	sb.WriteString("        # Allow established/related connections\n")
	sb.WriteString("        ct state established,related accept\n\n")

	sb.WriteString("        # Allow ICMP (ping) for diagnostics between VPN networks\n")
	sb.WriteString("        ip protocol icmp accept\n\n")

	// Generate allow rules based on ACL
	sb.WriteString("        # === VPN ACL Rules ===\n\n")

	// Track which pairs are already allowed
	allowedPairs := make(map[string]bool)

	// Handle "allow_all" policies first - these clients can reach everyone
	for _, c := range clients {
		if c.Policy == helper.ACLPolicyAllowAll {
			// Sanitize name for use in nftables comment (remove newlines and special chars)
			safeName := sanitizeForComment(c.Name)
			sb.WriteString(fmt.Sprintf("        # %s [allow_all policy]\n", safeName))
			// Allow this client to reach all VPN networks
			if wgIPRange != "" {
				sb.WriteString(fmt.Sprintf("        ip saddr %s ip daddr %s accept\n", c.IP, wgIPRange))
			}
			if hsIPRange != "" {
				sb.WriteString(fmt.Sprintf("        ip saddr %s ip daddr %s accept\n", c.IP, hsIPRange))
			}
			sb.WriteString("\n")
		}
	}

	// Process explicit rules for "selected" policy clients
	for _, rule := range rules {
		src, srcExists := clients[rule.SourceID]
		dst, dstExists := clients[rule.TargetID]
		if !srcExists || !dstExists {
			continue
		}

		// Skip if source has block_all (isolated, can't reach anyone)
		if src.Policy == helper.ACLPolicyBlockAll {
			continue
		}

		// Skip if target has block_all (isolated, nobody can reach them)
		if dst.Policy == helper.ACLPolicyBlockAll {
			continue
		}

		// Skip if source has allow_all (already covered by wildcard rule above)
		if src.Policy == helper.ACLPolicyAllowAll {
			continue
		}

		key := fmt.Sprintf("%s->%s", src.IP, dst.IP)
		if !allowedPairs[key] {
			// Sanitize names for use in nftables comment
			sb.WriteString(fmt.Sprintf("        # %s -> %s\n", sanitizeForComment(src.Name), sanitizeForComment(dst.Name)))
			sb.WriteString(fmt.Sprintf("        ip saddr %s ip daddr %s accept\n\n", src.IP, dst.IP))
			allowedPairs[key] = true
		}
	}

	// Default: drop traffic between VPN networks that wasn't explicitly allowed
	sb.WriteString("        # Drop unallowed VPN-to-VPN traffic\n")
	if wgIPRange != "" && hsIPRange != "" {
		sb.WriteString(fmt.Sprintf("        ip saddr %s ip daddr %s drop\n", wgIPRange, hsIPRange))
		sb.WriteString(fmt.Sprintf("        ip saddr %s ip daddr %s drop\n", hsIPRange, wgIPRange))
	}
	// Also drop WG-to-WG traffic that wasn't allowed
	if wgIPRange != "" {
		sb.WriteString(fmt.Sprintf("        ip saddr %s ip daddr %s drop\n", wgIPRange, wgIPRange))
	}

	sb.WriteString("    }\n")
	sb.WriteString("}\n")

	return sb.String(), nil
}

// sanitizeForComment removes newlines and other characters that could break nftables comments
func sanitizeForComment(s string) string {
	result := strings.ReplaceAll(s, "\n", " ")
	result = strings.ReplaceAll(result, "\r", " ")
	result = strings.ReplaceAll(result, "#", "")
	return result
}

// RemoveNftablesRules removes the VPN ACL nftables rules
func RemoveNftablesRules() error {
	// Delete the table if it exists
	cmd := exec.Command("nft", "delete", "table", "inet", "vpn_acl")
	cmd.Run() // Ignore errors if table doesn't exist

	// Remove the file
	os.Remove(getNftablesPath())

	log.Printf("Removed VPN ACL nftables rules")
	return nil
}
